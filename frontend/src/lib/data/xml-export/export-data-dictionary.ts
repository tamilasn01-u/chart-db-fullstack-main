import type { Diagram } from '@/lib/domain/diagram';
import type { DBTable } from '@/lib/domain/db-table';
import type { DBField } from '@/lib/domain/db-field';

/**
 * Exports diagram schema as custom XML Data Dictionary
 * Format matches the achievement system template structure
 */
export function exportDataDictionary({
    diagram,
}: {
    diagram: Diagram;
}): string {
    const { tables = [], relationships = [] } = diagram;

    // Header comment
    const header = `<!--
    ${diagram.name || 'Database'} Data Dictionary
    Generated by ChartDB - ${new Date().toISOString()}
    
    Tables: ${tables.length}
    Relationships: ${relationships.length}
-->`;

    // Generate XML for all tables
    const tablesXml = tables
        .map((table) => generateTableXML(table, diagram))
        .join('\n\n');

    return `<?xml version="1.0" encoding="UTF-8"?>
${header}

${tablesXml}`;
}

/**
 * Generate XML for a single table with all columns, keys, indexes, and foreign keys
 */
function generateTableXML(table: DBTable, diagram: Diagram): string {
    const { fields = [] } = table;

    // Table description
    const description = table.comments || table.name;

    // Generate columns XML
    const columnsXml = fields
        .map((field) => generateColumnXML(field))
        .join('\n');

    // Primary key
    const primaryKeyXml = generatePrimaryKeyXML(table);

    // Foreign keys
    const foreignKeysXml = generateForeignKeysXML(table, diagram);

    // Indexes
    const indexesXml = generateIndexesXML(table);

    return `    <!-- ============================================================ -->
    <!-- Table: ${table.name.padEnd(50)} -->
    <!-- ============================================================ -->
    <table name="${escapeXml(table.name)}">
        <description>${escapeXml(description)}</description>
        <columns>
${columnsXml}
        </columns>${primaryKeyXml}${foreignKeysXml}${indexesXml}
    </table>`;
}

/**
 * Generate XML for a single column/field
 */
function generateColumnXML(field: DBField): string {
    const nullable = field.nullable ?? true;
    const hasDefault = field.default !== undefined && field.default !== null;
    const isPrimaryKey = field.primaryKey ?? false;

    // Determine data type with size
    const dataType = field.type.name || 'VARCHAR';
    const maxSize = field.characterMaximumLength;

    let columnXml = `            <column name="${escapeXml(field.name)}">
                <data-type>${escapeXml(dataType)}</data-type>`;

    // Add max-size if available
    if (maxSize) {
        columnXml += `\n                <max-size>${maxSize}</max-size>`;
    }

    // Add nullable
    columnXml += `\n                <nullable>${nullable}</nullable>`;

    // Add auto-increment / unique value generation
    if (field.increment || isPrimaryKey) {
        columnXml += `\n                <uniquevalue-generation>
                    <generator-name>${escapeXml(field.name)}</generator-name>
                </uniquevalue-generation>`;
    }

    // Add default value
    if (hasDefault) {
        columnXml += `\n                <default-value>${escapeXml(String(field.default))}</default-value>`;
    }

    // Add comment if available
    if (field.comments) {
        columnXml += `\n                <comment>${escapeXml(field.comments)}</comment>`;
    }

    columnXml += `\n            </column>`;

    return columnXml;
}

/**
 * Generate primary key XML
 */
function generatePrimaryKeyXML(table: DBTable): string {
    const primaryKeyFields = table.fields?.filter((f) => f.primaryKey) || [];

    if (primaryKeyFields.length === 0) {
        return '';
    }

    const pkName = `pk_${table.name}`;
    const pkColumns = primaryKeyFields
        .map(
            (f) =>
                `            <primary-key-column>${escapeXml(f.name)}</primary-key-column>`
        )
        .join('\n');

    return `
        <primary-key name="${escapeXml(pkName)}">
${pkColumns}
        </primary-key>`;
}

/**
 * Generate foreign keys XML from relationships
 */
function generateForeignKeysXML(table: DBTable, diagram: Diagram): string {
    const { relationships = [] } = diagram;

    // Find all relationships where this table is the source
    const tableForeignKeys = relationships.filter(
        (rel) => rel.sourceTableId === table.id
    );

    if (tableForeignKeys.length === 0) {
        return '';
    }

    const foreignKeysXml = tableForeignKeys
        .map((rel) => {
            const targetTable = diagram.tables?.find(
                (t) => t.id === rel.targetTableId
            );
            if (!targetTable) return '';

            const fkName = `fk_${table.name}_${targetTable.name}`;
            const refTableName = targetTable.name;

            // Build FK columns mapping
            const fkColumns =
                rel.sourceFieldId && rel.targetFieldId
                    ? `                <fk-columns>
                    <fk-column>
                        <fk-local-column>${escapeXml(getFieldName(table, rel.sourceFieldId))}</fk-local-column>
                        <fk-reference-column>${escapeXml(getFieldName(targetTable, rel.targetFieldId))}</fk-reference-column>
                    </fk-column>
                </fk-columns>`
                    : '';

            return `            <foreign-key name="${escapeXml(fkName)}" reference-table-name="${escapeXml(refTableName)}">
${fkColumns}
            </foreign-key>`;
        })
        .filter(Boolean)
        .join('\n');

    if (!foreignKeysXml) {
        return '';
    }

    return `
        <foreign-keys>
${foreignKeysXml}
        </foreign-keys>`;
}

/**
 * Generate indexes XML
 */
function generateIndexesXML(table: DBTable): string {
    const { indexes = [] } = table;

    if (indexes.length === 0) {
        return '';
    }

    const indexesXml = indexes
        .map((index) => {
            const indexColumns = index.fieldIds
                .map((fieldId) => {
                    const fieldName = getFieldName(table, fieldId);
                    return `                <index-column>${escapeXml(fieldName)}</index-column>`;
                })
                .join('\n');

            return `            <index name="${escapeXml(index.name)}">
${indexColumns}
            </index>`;
        })
        .join('\n');

    return `
        <indexes>
${indexesXml}
        </indexes>`;
}

/**
 * Helper: Get field name by ID
 */
function getFieldName(table: DBTable, fieldId: string): string {
    const field = table.fields?.find((f) => f.id === fieldId);
    return field?.name || fieldId;
}

/**
 * Helper: Escape XML special characters
 */
function escapeXml(text: string): string {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}
