package com.chartdb.service;

import com.chartdb.model.*;
import com.chartdb.exception.ResourceNotFoundException;
import com.chartdb.repository.DiagramRepository;
import com.chartdb.repository.TableRepository;
import com.chartdb.repository.RelationshipRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class ExportService {
    
    private final DiagramRepository diagramRepository;
    private final TableRepository tableRepository;
    private final RelationshipRepository relationshipRepository;
    private final PermissionService permissionService;
    private final ObjectMapper objectMapper;
    
    @Transactional(readOnly = true)
    public String exportAsSql(String diagramId, String dialect, String userId) {
        permissionService.checkReadAccess(diagramId, userId);
        
        Diagram diagram = diagramRepository.findById(diagramId)
            .orElseThrow(() -> new ResourceNotFoundException("Diagram not found"));
        
        List<DiagramTable> tables = tableRepository.findByDiagramIdOrderByCreatedAtAsc(diagramId);
        List<Relationship> relationships = relationshipRepository.findByDiagramId(diagramId);
        
        return generateSqlDdl(diagram, tables, relationships, dialect);
    }
    
    @Transactional(readOnly = true)
    public String exportAsJson(String diagramId, String userId) {
        permissionService.checkReadAccess(diagramId, userId);
        
        Diagram diagram = diagramRepository.findById(diagramId)
            .orElseThrow(() -> new ResourceNotFoundException("Diagram not found"));
        
        List<DiagramTable> tables = tableRepository.findByDiagramIdOrderByCreatedAtAsc(diagramId);
        List<Relationship> relationships = relationshipRepository.findByDiagramId(diagramId);
        
        return generateJsonExport(diagram, tables, relationships);
    }
    
    @Transactional(readOnly = true)
    public byte[] exportAsPng(String diagramId, int scale, String userId) {
        permissionService.checkReadAccess(diagramId, userId);
        // Server-side PNG rendering would require additional libraries
        // This is a placeholder - in production you might use a headless browser
        throw new UnsupportedOperationException("Server-side PNG export not implemented. Use client-side export.");
    }
    
    private String generateSqlDdl(Diagram diagram, List<DiagramTable> tables, 
                                   List<Relationship> relationships, String dialect) {
        StringBuilder sql = new StringBuilder();
        
        // Header comment
        sql.append("-- Generated by ChartDB\n");
        sql.append("-- Diagram: ").append(diagram.getName()).append("\n");
        sql.append("-- Database: ").append(dialect.toUpperCase()).append("\n");
        sql.append("-- Generated at: ").append(new Date()).append("\n\n");
        
        // Group relationships by source table for FK generation
        Map<String, List<Relationship>> relationshipsByTable = relationships.stream()
            .collect(Collectors.groupingBy(rel -> rel.getSourceTable().getId()));
        
        // Generate CREATE TABLE statements
        for (DiagramTable table : tables) {
            sql.append(generateCreateTable(table, relationshipsByTable.get(table.getId()), dialect));
            sql.append("\n\n");
        }
        
        // Generate ALTER TABLE for foreign keys (safer approach)
        for (Relationship rel : relationships) {
            sql.append(generateForeignKey(rel, tables, dialect));
        }
        
        return sql.toString();
    }
    
    private String generateCreateTable(DiagramTable table, List<Relationship> tableFks, String dialect) {
        StringBuilder sql = new StringBuilder();
        
        String tableName = quoteIdentifier(table.getName(), dialect);
        sql.append("CREATE TABLE ").append(tableName).append(" (\n");
        
        List<TableColumn> columns = table.getColumns();
        List<String> primaryKeys = new ArrayList<>();
        
        for (int i = 0; i < columns.size(); i++) {
            TableColumn col = columns.get(i);
            sql.append("    ");
            sql.append(quoteIdentifier(col.getName(), dialect));
            sql.append(" ").append(mapDataType(col.getDataType(), dialect));
            
            if (Boolean.FALSE.equals(col.getIsNullable())) {
                sql.append(" NOT NULL");
            }
            
            if (Boolean.TRUE.equals(col.getIsUnique()) && !Boolean.TRUE.equals(col.getIsPrimaryKey())) {
                sql.append(" UNIQUE");
            }
            
            if (col.getDefaultValue() != null && !col.getDefaultValue().isEmpty()) {
                sql.append(" DEFAULT ").append(col.getDefaultValue());
            }
            
            if (Boolean.TRUE.equals(col.getIsPrimaryKey())) {
                primaryKeys.add(col.getName());
            }
            
            if (i < columns.size() - 1 || !primaryKeys.isEmpty()) {
                sql.append(",");
            }
            
            if (col.getDescription() != null && !col.getDescription().isEmpty()) {
                sql.append(" -- ").append(col.getDescription());
            }
            
            sql.append("\n");
        }
        
        // Primary key constraint
        if (!primaryKeys.isEmpty()) {
            sql.append("    CONSTRAINT ").append(quoteIdentifier("pk_" + table.getName(), dialect));
            sql.append(" PRIMARY KEY (");
            sql.append(primaryKeys.stream()
                .map(pk -> quoteIdentifier(pk, dialect))
                .collect(Collectors.joining(", ")));
            sql.append(")\n");
        }
        
        sql.append(");");
        
        // Table comment
        if (table.getDescription() != null && !table.getDescription().isEmpty()) {
            sql.append("\n");
            sql.append(generateTableComment(table, dialect));
        }
        
        return sql.toString();
    }
    
    private String generateForeignKey(Relationship rel, List<DiagramTable> tables, String dialect) {
        StringBuilder sql = new StringBuilder();
        
        String sourceTableId = rel.getSourceTable() != null ? rel.getSourceTable().getId() : null;
        String targetTableId = rel.getTargetTable() != null ? rel.getTargetTable().getId() : null;
        String sourceColumnId = rel.getSourceColumn() != null ? rel.getSourceColumn().getId() : null;
        String targetColumnId = rel.getTargetColumn() != null ? rel.getTargetColumn().getId() : null;
        
        String sourceTableName = findTableName(sourceTableId, tables);
        String targetTableName = findTableName(targetTableId, tables);
        String sourceColumnName = findColumnName(sourceColumnId, tables);
        String targetColumnName = findColumnName(targetColumnId, tables);
        
        if (sourceTableName == null || targetTableName == null || 
            sourceColumnName == null || targetColumnName == null) {
            return "";
        }
        
        String constraintName = rel.getName() != null ? rel.getName() : 
            "fk_" + sourceTableName + "_" + targetTableName;
        
        sql.append("ALTER TABLE ").append(quoteIdentifier(sourceTableName, dialect));
        sql.append("\n    ADD CONSTRAINT ").append(quoteIdentifier(constraintName, dialect));
        sql.append("\n    FOREIGN KEY (").append(quoteIdentifier(sourceColumnName, dialect)).append(")");
        sql.append("\n    REFERENCES ").append(quoteIdentifier(targetTableName, dialect));
        sql.append("(").append(quoteIdentifier(targetColumnName, dialect)).append(")");
        
        if (rel.getOnDelete() != null && !rel.getOnDelete().isEmpty()) {
            sql.append("\n    ON DELETE ").append(rel.getOnDelete().replace("_", " "));
        }
        if (rel.getOnUpdate() != null && !rel.getOnUpdate().isEmpty()) {
            sql.append("\n    ON UPDATE ").append(rel.getOnUpdate().replace("_", " "));
        }
        
        sql.append(";\n\n");
        
        return sql.toString();
    }
    
    private String findTableName(String tableId, List<DiagramTable> tables) {
        return tables.stream()
            .filter(t -> t.getId().equals(tableId))
            .map(DiagramTable::getName)
            .findFirst()
            .orElse(null);
    }
    
    private String findColumnName(String columnId, List<DiagramTable> tables) {
        for (DiagramTable table : tables) {
            for (TableColumn col : table.getColumns()) {
                if (col.getId().equals(columnId)) {
                    return col.getName();
                }
            }
        }
        return null;
    }
    
    private String quoteIdentifier(String identifier, String dialect) {
        return switch (dialect.toLowerCase()) {
            case "mysql", "mariadb" -> "`" + identifier + "`";
            case "mssql", "sqlserver" -> "[" + identifier + "]";
            default -> "\"" + identifier + "\""; // PostgreSQL, Oracle, standard SQL
        };
    }
    
    private String mapDataType(String dataType, String dialect) {
        // Basic type mapping - can be extended
        String upperType = dataType.toUpperCase();
        
        return switch (dialect.toLowerCase()) {
            case "mysql", "mariadb" -> mapToMySql(upperType);
            case "mssql", "sqlserver" -> mapToMsSql(upperType);
            case "sqlite" -> mapToSqlite(upperType);
            default -> dataType; // PostgreSQL - use as-is
        };
    }
    
    private String mapToMySql(String type) {
        if (type.contains("SERIAL")) return type.replace("SERIAL", "INT AUTO_INCREMENT");
        if (type.equals("TEXT")) return "LONGTEXT";
        if (type.equals("BOOLEAN")) return "TINYINT(1)";
        if (type.equals("UUID")) return "CHAR(36)";
        return type;
    }
    
    private String mapToMsSql(String type) {
        if (type.contains("SERIAL")) return type.replace("SERIAL", "INT IDENTITY");
        if (type.equals("TEXT")) return "NVARCHAR(MAX)";
        if (type.equals("BOOLEAN")) return "BIT";
        if (type.equals("UUID")) return "UNIQUEIDENTIFIER";
        if (type.startsWith("VARCHAR")) return type.replace("VARCHAR", "NVARCHAR");
        return type;
    }
    
    private String mapToSqlite(String type) {
        if (type.contains("SERIAL")) return "INTEGER PRIMARY KEY AUTOINCREMENT";
        if (type.contains("INT")) return "INTEGER";
        if (type.equals("BOOLEAN")) return "INTEGER";
        return type;
    }
    
    private String generateTableComment(DiagramTable table, String dialect) {
        return switch (dialect.toLowerCase()) {
            case "mysql", "mariadb" -> String.format("ALTER TABLE %s COMMENT = '%s';",
                quoteIdentifier(table.getName(), dialect),
                escapeString(table.getDescription()));
            case "postgresql" -> String.format("COMMENT ON TABLE %s IS '%s';",
                quoteIdentifier(table.getName(), dialect),
                escapeString(table.getDescription()));
            case "mssql", "sqlserver" -> String.format(
                "EXEC sp_addextendedproperty 'MS_Description', '%s', 'SCHEMA', 'dbo', 'TABLE', '%s';",
                escapeString(table.getDescription()), table.getName());
            default -> "";
        };
    }
    
    private String escapeString(String str) {
        return str != null ? str.replace("'", "''") : "";
    }
    
    private String generateJsonExport(Diagram diagram, List<DiagramTable> tables, 
                                       List<Relationship> relationships) {
        Map<String, Object> export = new LinkedHashMap<>();
        
        // Diagram metadata
        Map<String, Object> diagramData = new LinkedHashMap<>();
        diagramData.put("id", diagram.getId());
        diagramData.put("name", diagram.getName());
        diagramData.put("description", diagram.getDescription());
        diagramData.put("databaseType", diagram.getDatabaseType());
        diagramData.put("createdAt", diagram.getCreatedAt());
        diagramData.put("updatedAt", diagram.getUpdatedAt());
        export.put("diagram", diagramData);
        
        // Tables with columns
        List<Map<String, Object>> tablesData = tables.stream().map(table -> {
            Map<String, Object> tableData = new LinkedHashMap<>();
            tableData.put("id", table.getId());
            tableData.put("name", table.getName());
            tableData.put("displayName", table.getDisplayName());
            tableData.put("schema", table.getSchemaName());
            tableData.put("comment", table.getDescription());
            tableData.put("positionX", table.getPositionX());
            tableData.put("positionY", table.getPositionY());
            tableData.put("width", table.getWidth());
            tableData.put("color", table.getColor());
            
            List<Map<String, Object>> columnsData = table.getColumns().stream().map(col -> {
                Map<String, Object> colData = new LinkedHashMap<>();
                colData.put("id", col.getId());
                colData.put("name", col.getName());
                colData.put("dataType", col.getDataType());
                colData.put("isPrimaryKey", col.getIsPrimaryKey());
                colData.put("isForeignKey", col.getIsForeignKey());
                colData.put("isNullable", col.getIsNullable());
                colData.put("isUnique", col.getIsUnique());
                colData.put("defaultValue", col.getDefaultValue());
                colData.put("comment", col.getDescription());
                colData.put("orderIndex", col.getOrderIndex());
                return colData;
            }).collect(Collectors.toList());
            
            tableData.put("columns", columnsData);
            return tableData;
        }).collect(Collectors.toList());
        export.put("tables", tablesData);
        
        // Relationships
        List<Map<String, Object>> relData = relationships.stream().map(rel -> {
            Map<String, Object> r = new LinkedHashMap<>();
            r.put("id", rel.getId());
            r.put("name", rel.getName());
            r.put("sourceTableId", rel.getSourceTable() != null ? rel.getSourceTable().getId() : null);
            r.put("sourceColumnId", rel.getSourceColumn() != null ? rel.getSourceColumn().getId() : null);
            r.put("targetTableId", rel.getTargetTable() != null ? rel.getTargetTable().getId() : null);
            r.put("targetColumnId", rel.getTargetColumn() != null ? rel.getTargetColumn().getId() : null);
            r.put("type", rel.getRelationshipType() != null ? rel.getRelationshipType().name() : null);
            r.put("onDelete", rel.getOnDelete());
            r.put("onUpdate", rel.getOnUpdate());
            return r;
        }).collect(Collectors.toList());
        export.put("relationships", relData);
        
        try {
            ObjectMapper prettyMapper = objectMapper.copy();
            prettyMapper.enable(SerializationFeature.INDENT_OUTPUT);
            return prettyMapper.writeValueAsString(export);
        } catch (JsonProcessingException e) {
            log.error("Error generating JSON export", e);
            throw new RuntimeException("Failed to generate JSON export", e);
        }
    }
}
